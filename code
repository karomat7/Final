import java.io.*;
import java.util.*;

public class Kdnn {

  
    static class Word {
        String word;       
        float[] vector;    // The vector that represents the word

        Word(String word, float[] vector) {
            this.word = word;      
            this.vector = vector;  
        }
    }
 static class KDTree {
        
        // Node class represents each point (word and its vector) in the tree
        static class Node {
            Word word;         
            Node left;          
            Node right;         
            int dimension;      

            Node(Word word, int dimension) {
                this.word = word;                   // Set the word at the node
                this.dimension = dimension;         // Set the dimension for splitting
            }
        }
private Node root;              // Root of the k-d tree
        private int dimensions;         // Number of dimensions of the vectors

        // Builds the k-d tree by recursively dividing the data
        public void buildTree(List<Word> words, int depth) {
            dimensions = words.get(0).vector.length;            // Set the number of dimensions
            root = buildTreeRecursive(words, depth);            // Start building from root
        }

        // Helper method to recursively build the tree
        private Node buildTreeRecursive(List<Word> words, int depth) {
            if (words.isEmpty()) {
                return null;            // Base case: if the list is empty, return null
            }

            int axis = depth % dimensions;         
            words.sort(Comparator.comparingDouble(w -> w.vector[axis]));  // Sort words by chosen dimension

            int medianIndex = words.size() / 2;         // Find the middle word
            Word medianWord = words.get(medianIndex);   // Get the median word

            Node node = new Node(medianWord, axis);                                                     // Create a new node with the median word
            node.left = buildTreeRecursive(words.subList(0, medianIndex), depth + 1);                   // Build the left subtree
            node.right = buildTreeRecursive(words.subList(medianIndex + 1, words.size()), depth + 1);   // Build the right subtree

            return node;  // Return the node
        }
public Word findNearN(float[] targetVector) {
            return findNearNRec(root, targetVector, Double.MAX_VALUE, null);        // Start recursion from the root
        }

        // Helper method for recursively finding the nearest neighbor
        private Word findNearNRec(Node node, float[] targetVector, double bestDist, Word bestWord) {
            if (node == null) {
                return bestWord;                  // Base case: if node is null, return the best word
            }

            double dist = calcDist(targetVector, node.word.vector);     // Calculate the distance between target and current node
            if (dist < bestDist) {
                bestDist = dist;                                        // Update best distance if a closer neighbor is found
                bestWord = node.word;                                   // Update best word with current node's word
            }

            Node nearNode = targetVector[node.dimension] < node.word.vector[node.dimension] ? node.left : node.right;
            Node farNode = targetVector[node.dimension] < node.word.vector[node.dimension] ? node.right : node.left;

            // Go through the near subtree
            bestWord = findNearNRec(nearNode, targetVector, bestDist, bestWord);

            // Go through the far subtree (if necessary)
            if (Math.abs(targetVector[node.dimension] - node.word.vector[node.dimension]) < bestDist) {
                bestWord = findNearNRec(farNode, targetVector, bestDist, bestWord);
            }

            return bestWord;        // Return the best word found
        }
public double calcDist(float[] vector1, float[] vector2) {
            double sum = 0;
            for (int i = 0; i < vector1.length; i++) {
                sum += Math.pow(vector1[i] - vector2[i], 2);  // Sum of squared differences
            }
            return Math.sqrt(sum);                            // Return the square root of the sum 
                    }

        // Get Height of the k-d tree
        public int getH() {
            return getHRec(root);  // Start the recursion from the root
        }

        // Helper method for calculating tree height recursively
        private int getHRec(Node node) {
            if (node == null) {
                return 0;               // If the node is null, the height is 0
            }

            int leftHeight = getHRec(node.left);        // Get the height of the left subtree
            int rightHeight = getHRec(node.right);      // Get the height of the right subtree

            return Math.max(leftHeight, rightHeight) + 1;       // Return the larger height + 1
        }

        // Get the min height of a perfectly balanced k-d tree
        public int getMinH(int numNodes) {
            return (int) Math.floor(Math.log(numNodes) / Math.log(2)) + 1;          // Calculate the min height
        }
    }
public static void main(String[] args) {
        if (args.length != 2) {
            System.out.println("Usage: java Kdnn <test file> <data file>");
            return;
        }

        String testFile = args[0];  
        String dataFile = args[1];  

        List<Word> words = readWordsFromFile(dataFile);         // Read the words from the data file
        List<Word> testWords = readWordsFromFile(testFile);     // Read the test words

        KDTree tree = new KDTree();         // Create a new k-d tree
        tree.buildTree(words, 0);           // Build the tree with the given words

        // Print tree height and minheight comparison
        int treeHeight = tree.getH();
        int minH = tree.getMinH(words.size());
        System.out.println("Tree Height: " + treeHeight);
        System.out.println("Minimal Height: " + minH);

        // Check if the k-d tree is balanced
        if (treeHeight <= minH) {
            System.out.println("The k-d tree is well balanced.");
        } else {
            System.out.println("The k-d tree is not perfectly balanced.");
        }

        // Check via testing that the k-d tree holds all points from the test file
        verifyTestFile(tree, testWords);

        // Find nearest neighbor for each test word
        verifyNearestNeighbors(tree, testWords);
    }
 // Reads the words from a file and returns them as a list of Word objects
    public static List<Word> readWordsFromFile(String fileName) {
        List<Word> words = new ArrayList<>();

        try (Scanner scanner = new Scanner(new File(fileName))) {
            int numWords = scanner.nextInt();               // Num of words
            int dimension = scanner.nextInt();              // Dimension of the word vectors

            // Read each word and its vector
            while (scanner.hasNext()) {
                String word = scanner.next();
                float[] vector = new float[dimension];
                for (int i = 0; i < dimension; i++) {
                    vector[i] = scanner.nextFloat();            // Read each dimension of the vector
                }
                words.add(new Word(word, vector));              // Add the word to the list
            }
        } catch (FileNotFoundException e) {
            System.out.println("File not found: " + fileName);
            e.printStackTrace();
        }
        return words;            // Ret the list of words
    }
// Checks if words from the test file are in the k-d tree
    public static void verifyTestFile(KDTree tree, List<Word> testWords) {
        System.out.println("Verifying if words from test file are in the k-d tree:");
        for (Word testWord : testWords) {
            Word nearest = tree.findNearN(testWord.vector);                                     // Find nearest word in the tree
            if (nearest != null) {
                System.out.println("Found: " + testWord.word + " nearest " + nearest.word);     // Print the nearest word
            } else {
                System.out.println("Word not found in the tree: " + testWord.word);             // Print if word not found
            }
        }
    }

    // Finds the nearest neighbors for each test word
    public static void verifyNearestNeighbors(KDTree tree, List<Word> testWords) {
        int index = 0;
        for (Word testWord : testWords) { 
            Word nearest = tree.findNearN(testWord.vector);                                     // Find the nearest neighbor
            double distance = tree.calcDist(testWord.vector, nearest.vector);                   // Calculate the distance
            System.out.println("testword_" + index + ": nearest = " + nearest.word + " distance = " + distance);
            index++;
        }
    }
}
